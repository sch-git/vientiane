
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">vientiane/server/controller/account.go (2.9%)</option>
				
				<option value="file1">vientiane/server/controller/article.go (6.7%)</option>
				
				<option value="file2">vientiane/server/controller/health.go (33.3%)</option>
				
				<option value="file3">vientiane/server/controller/init.go (100.0%)</option>
				
				<option value="file4">vientiane/server/controller/service.go (0.0%)</option>
				
				<option value="file5">vientiane/server/dao/account.go (30.6%)</option>
				
				<option value="file6">vientiane/server/dao/article.go (22.2%)</option>
				
				<option value="file7">vientiane/server/dao/doc.go (0.0%)</option>
				
				<option value="file8">vientiane/server/dao/index.go (0.0%)</option>
				
				<option value="file9">vientiane/server/database/mysql.go (53.3%)</option>
				
				<option value="file10">vientiane/server/models/account.go (16.7%)</option>
				
				<option value="file11">vientiane/server/models/article.go (33.3%)</option>
				
				<option value="file12">vientiane/server/models/content.go (0.0%)</option>
				
				<option value="file13">vientiane/server/models/doc.go (0.0%)</option>
				
				<option value="file14">vientiane/server/mq/article.go (0.0%)</option>
				
				<option value="file15">vientiane/server/service/account.go (3.8%)</option>
				
				<option value="file16">vientiane/server/service/article.go (2.4%)</option>
				
				<option value="file17">vientiane/server/service/dataquery.go (0.0%)</option>
				
				<option value="file18">vientiane/server/service/entity/conditions.go (22.2%)</option>
				
				<option value="file19">vientiane/server/service/init.go (100.0%)</option>
				
				<option value="file20">vientiane/server/utils/aes.go (81.2%)</option>
				
				<option value="file21">vientiane/server/utils/email.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "context"
        "go.uber.org/zap"
        vientiane "vientiane/pub/idl/grpc"
        "vientiane/server/consts"
        "vientiane/server/models"
        "vientiane/server/service"
)

type accountController struct {
        service models.AccountService
}

func NewAccountController() *accountController <span class="cov8" title="1">{
        return &amp;accountController{
                service: service.NewAccountService(),
        }
}</span>

func (c *accountController) GetAccount(ctx context.Context, req *vientiane.GetAccountReq) (res *vientiane.GetAccountRes) <span class="cov0" title="0">{
        fun := "accountController.GetAccount--&gt;"

        if nil == req </span><span class="cov0" title="0">{
                vlog.Error(fun, zap.String("req", "req is nil"))
                res = &amp;vientiane.GetAccountRes{Code: consts.InvalidReqIsNil, Msg: consts.InvalidReqIsNilMsg}
                return
        }</span>

        <span class="cov0" title="0">account, err := c.service.Get(ctx, req.Id)
        if nil != err </span><span class="cov0" title="0">{
                vlog.Error(fun, zap.Error(err))
                res = &amp;vientiane.GetAccountRes{Code: consts.ServerErr, Msg: err.Error()}
                return
        }</span>

        <span class="cov0" title="0">res = &amp;vientiane.GetAccountRes{
                Code: consts.StatusOK,
                Data: &amp;vientiane.GetAccountData{
                        Account: account.ToGrpc(),
                },
        }
        return</span>
}

func (c *accountController) ListAccount(ctx context.Context, req *vientiane.ListAccountReq) (res *vientiane.ListAccountRes) <span class="cov0" title="0">{
        fun := "accountController.ListAccount--&gt;"
        res = &amp;vientiane.ListAccountRes{}

        if nil == req </span><span class="cov0" title="0">{
                vlog.Error(fun, zap.String("req", "req is nil"))
                res = &amp;vientiane.ListAccountRes{Code: consts.InvalidReqIsNil, Msg: consts.InvalidReqIsNilMsg}
                return
        }</span>

        <span class="cov0" title="0">account := &amp;models.Account{
                Name:   req.Name,
                Email:  req.Email,
                Limit:  req.Limit,
                Offset: req.Offset,
        }
        accounts, err := c.service.List(ctx, account)
        if nil != err </span><span class="cov0" title="0">{
                vlog.Error(fun, zap.Error(err))
                res = &amp;vientiane.ListAccountRes{Code: consts.ServerErr, Msg: err.Error()}
                return
        }</span>

        <span class="cov0" title="0">res.Data = &amp;vientiane.ListAccountData{
                Accounts: func() []*vientiane.Account </span><span class="cov0" title="0">{
                        grpcAccounts := make([]*vientiane.Account, 0)
                        if len(accounts) &lt; 1 </span><span class="cov0" title="0">{
                                return grpcAccounts
                        }</span>

                        <span class="cov0" title="0">for _, account := range accounts </span><span class="cov0" title="0">{
                                if nil == account </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">grpcAccounts = append(grpcAccounts, account.ToGrpc())</span>
                        }
                        <span class="cov0" title="0">return grpcAccounts</span>
                }(),
                Offset: req.Offset + int64(len(accounts)),
                //Count: TODO
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "context"
        "go.uber.org/zap"
        "log"
        vientiane "vientiane/pub/idl/grpc"
        "vientiane/server/consts"
        "vientiane/server/models"
        "vientiane/server/service"
)

type articleController struct {
        service models.ArticleService
}

func NewArticleController() *articleController <span class="cov8" title="1">{
        return &amp;articleController{
                service: service.NewArticleService(),
        }
}</span>

func (c *articleController) GetArticle(ctx context.Context, req *vientiane.GetArticleReq) (res *vientiane.GetArticleRes) <span class="cov0" title="0">{
        fun := "articleController.GetArticle--&gt;"

        if nil == req </span><span class="cov0" title="0">{
                vlog.Error(fun, zap.String("req", "req is nil"))
                res = &amp;vientiane.GetArticleRes{Code: consts.InvalidReqIsNil, Msg: consts.InvalidReqIsNilMsg}
                return
        }</span>

        <span class="cov0" title="0">article, err := c.service.Get(ctx, req.Id)
        if nil != err </span><span class="cov0" title="0">{
                vlog.Error(fun, zap.Error(err))
                res = &amp;vientiane.GetArticleRes{Code: consts.ServerErr, Msg: err.Error()}
                return
        }</span>
        <span class="cov0" title="0">log.Println(req.GetId())
        log.Println(article)

        res = &amp;vientiane.GetArticleRes{
                Code: consts.StatusOK,
                Data: &amp;vientiane.GetArticleData{
                        Article: article.ToGrpc(),
                },
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "context"
        . "vientiane/pub/idl/grpc"
)

type healthController struct {
}

func NewHealthController() *healthController <span class="cov8" title="1">{
        return &amp;healthController{}
}</span>

func (c *healthController) HealthCheck(ctx context.Context, req *HealthCheckReq) (res *HealthCheckRes) <span class="cov0" title="0">{
        res = &amp;HealthCheckRes{
                Data: &amp;HealthCheckData{},
        }
        return
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "go.uber.org/zap"
        vientiane "vientiane/pub/idl/grpc"
)

type VientianeServiceImpl struct {
        health                                 *healthController
        account                                *accountController
        article *articleController
        vientiane.UnsafeVientianeServiceServer // 通过这个类，继承了 mustEmbedUnimplementedVientianeServiceServer 方法
}

var (
        HandleVientiane *VientianeServiceImpl
        vlog            *zap.Logger
)

func init() <span class="cov8" title="1">{
        HandleVientiane = &amp;VientianeServiceImpl{
                health:  NewHealthController(),
                account: NewAccountController(),
                article: NewArticleController(),
        }
        vlog = zap.NewExample()
        defer vlog.Sync()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "context"
        . "vientiane/pub/idl/grpc"
)

func (s *VientianeServiceImpl) HealthCheck(ctx context.Context, req *HealthCheckReq) (res *HealthCheckRes, err error) <span class="cov0" title="0">{
        return HandleVientiane.health.HealthCheck(ctx, req), nil
}</span>

// account

func (s *VientianeServiceImpl) GetAccount(ctx context.Context, req *GetAccountReq) (*GetAccountRes, error) <span class="cov0" title="0">{
        return HandleVientiane.account.GetAccount(ctx, req), nil
}</span>

func (s *VientianeServiceImpl) ListAccount(ctx context.Context, req *ListAccountReq) (*ListAccountRes, error) <span class="cov0" title="0">{
        return HandleVientiane.account.ListAccount(ctx, req), nil
}</span>

// category

func (s *VientianeServiceImpl) ListCategory(ctx context.Context, req *ListCategoryReq) (*ListCategoryRes, error) <span class="cov0" title="0">{
        panic("unimplemented func")</span>
}

func (s *VientianeServiceImpl)GetArticle(ctx context.Context,req *GetArticleReq)(*GetArticleRes,error)  <span class="cov0" title="0">{
        return HandleVientiane.article.GetArticle(ctx,req),nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package dao

import (
        "context"
        "errors"
        "fmt"
        "gorm.io/gorm"
        "time"
        "vientiane/server/models"
)

type AccountDAO struct {
}

func NewAccountDAO() *AccountDAO <span class="cov8" title="1">{
        return &amp;AccountDAO{}
}</span>

func (d *AccountDAO) Add(ctx context.Context, account *models.Account, db *gorm.DB) (err error) <span class="cov8" title="1">{
        fun := "AccountDAO.Add--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov8" title="1">if nil == account </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s account is nil or id is empty", fun)
                return
        }</span>

        <span class="cov8" title="1">err = db.Create(account).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s %v", fun, err)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (d *AccountDAO) Get(ctx context.Context, id int64, db *gorm.DB) (account *models.Account, err error) <span class="cov8" title="1">{
        fun := "AccountDAO.Get--&gt;"

        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov8" title="1">result := db.Where("id=?", id).First(&amp;account)
        if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                account = &amp;models.Account{}
                //glog.Infof("%s get account by id: %d err: not found", fun, id)
                return
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get account by id: %d err: %v", fun, id, result.Error)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (d *AccountDAO) List(ctx context.Context, account *models.Account, db *gorm.DB) (accounts []*models.Account, err error) <span class="cov8" title="1">{
        fun := "AccountDAO.List--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov8" title="1">if nil == account </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s account is nil", fun)
                return
        }</span>

        <span class="cov8" title="1">if account.Name != "" </span><span class="cov0" title="0">{
                db = db.Where("name like ?", "%"+account.Name+"%")
        }</span>
        <span class="cov8" title="1">if account.Email != "" </span><span class="cov0" title="0">{
                db = db.Where("email = ?", account.Email)
        }</span>
        <span class="cov8" title="1">db = db.Offset(int(account.Offset)).Limit(int(account.Limit))

        err = db.Find(&amp;accounts).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s list account by req: %v err: %v", fun, account, err)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (d *AccountDAO) Set(ctx context.Context, account *models.Account, db *gorm.DB) (err error) <span class="cov0" title="0">{
        fun := "AccountDAO.Set--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">if nil == account || account.Id &lt; 1 </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s account is nil or id is empty", fun)
                return
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "name":       account.Name,
                "email":      account.Email,
                "updated_at": time.Now(),
        }
        if account.Password != "" </span><span class="cov0" title="0">{
                data["password"] = account.Password
        }</span>
        <span class="cov0" title="0">where := map[string]interface{}{
                "id": account.Id,
        }

        err = db.Model(&amp;account).Where(where).Updates(data).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s update account err: %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (d *AccountDAO) Count(ctx context.Context, account *models.Account, db *gorm.DB) (count int64, err error) <span class="cov0" title="0">{
        fun := "AccountDAO.Count--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">db = db.Model(account)
        if account.Name != "" </span><span class="cov0" title="0">{
                db = db.Where("name like ?", "%"+account.Name+"%")
        }</span>
        <span class="cov0" title="0">if account.Email != "" </span><span class="cov0" title="0">{
                db = db.Where("email = ?", account.Email)
        }</span>
        <span class="cov0" title="0">err = db.Count(&amp;count).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dao

import (
        "context"
        "errors"
        "fmt"
        "gorm.io/gorm"
        "vientiane/server/models"
)

type ArticleDAO struct {
}

func NewArticleDAO() *ArticleDAO <span class="cov8" title="1">{
        return &amp;ArticleDAO{}
}</span>

func (d *ArticleDAO) Add(ctx context.Context, article *models.Article, db *gorm.DB) (err error) <span class="cov8" title="1">{
        fun := "ArticleDAO.Add--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov8" title="1">if nil == article || article.IsEmpty() </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s article is nil or article is empty", fun)
                return
        }</span>

        <span class="cov8" title="1">err = db.Create(article).Error
        if nil != err </span><span class="cov8" title="1">{
                err = fmt.Errorf("%s %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (d *ArticleDAO) Get(ctx context.Context, id int64, db *gorm.DB) (article *models.Article, err error) <span class="cov8" title="1">{
        fun := "ArticleDAO.Get--&gt;"

        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov8" title="1">result := db.Where("id=?", id).First(&amp;article)
        if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                article = &amp;models.Article{}
                return
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("%s get article by id: %d err: %v", fun, id, result.Error)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (d *ArticleDAO) List(ctx context.Context, article *models.Article, db *gorm.DB) (articles []*models.Account, err error) <span class="cov0" title="0">{
        fun := "ArticleDAO.List--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">if nil == article </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s article is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">db = db.Offset(int(article.Offset)).Limit(int(article.Limit))

        err = db.Find(&amp;articles).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s list article by req: %v err: %v", fun, article, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (d *ArticleDAO) Set(ctx context.Context, article *models.Article, db *gorm.DB) (err error) <span class="cov0" title="0">{
        fun := "ArticleDAO.Set--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">if nil == article || article.Id &lt; 1 </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s article is nil or id is empty", fun)
                return
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "title":   article.Title,
                "content": article.Content,
        }
        where := map[string]interface{}{
                "id": article.Id,
        }

        err = db.Model(&amp;article).Where(where).Updates(data).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s update article err: %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (d *ArticleDAO) Count(ctx context.Context, article *models.Article, db *gorm.DB) (count int64, err error) <span class="cov0" title="0">{
        fun := "ArticleDAO.Count--&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">db = db.Model(article)
        err = db.Count(&amp;count).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (d *ArticleDAO) Del(ctx context.Context, id int64, db *gorm.DB) (err error) <span class="cov0" title="0">{
        fun := "ArticleDAO.Del --&gt;"
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">db = db.Delete(&amp;models.Article{Id: id})
        err = db.Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s %v",fun,err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dao

import (
        "context"
        "fmt"
        "gorm.io/gorm"
        "vientiane/server/models"
)

type DocDAO struct {
}

func NewDocDAO() *DocDAO <span class="cov0" title="0">{
        return &amp;DocDAO{}
}</span>

func (d *DocDAO) Add(ctx context.Context, doc *models.Doc, db *gorm.DB) (err error) <span class="cov0" title="0">{
        fun := "DocDAO.Add --&gt;"
        if nil == db || nil == doc </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s db: %v or doc:%v is nil", fun, db, doc)
                return
        }</span>

        <span class="cov0" title="0">err = db.Create(doc).Error
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s add doc err: %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dao

import (
        "github.com/elastic/go-elasticsearch/v8"
        "log"
)

type IndexDAO interface {
}

type indexDAO struct {
        esClient *elasticsearch.Client
}

func NewIndexDAO() IndexDAO <span class="cov0" title="0">{
        cfg := elasticsearch.Config{
                Addresses: []string{"https://localhost:9200"},
        }
        es, err := elasticsearch.NewClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return &amp;indexDAO{
                esClient: es,
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
        "time"
)

var (
        dsn string
        db *gorm.DB
        sqlDB *sql.DB
)

func init() <span class="cov8" title="1">{
        dsn = "root:sch1324!/@tcp(localhost:3306)/vientiane?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"
}</span>

type DB struct{}

func init()  <span class="cov8" title="1">{
        db,_ = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        sqlDB,_ = db.DB()
        sqlDB.SetConnMaxLifetime(time.Hour)
        sqlDB.SetMaxOpenConns(1000)
        sqlDB.SetMaxIdleConns(1000)
}</span>

func NewDB() ManagerDB <span class="cov8" title="1">{
        return &amp;DB{}
}</span>

type ManagerDB interface {
        GetDB() (*gorm.DB, error)
        Begin() (db *gorm.DB, err error)
}

func (d *DB) Begin() (db *gorm.DB, err error) <span class="cov0" title="0">{
        fun := "GetTX--&gt;"
        db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s: get tx err: %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">tx := db.Begin()
        return tx, err</span>
}

func (d *DB) GetDB() (*gorm.DB, error) <span class="cov8" title="1">{
        return db,nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

import (
        "context"
        "time"
        pub "vientiane/pub/idl/grpc"
        "vientiane/server/consts"
)

const accountTableName = "vientiane_account"

type AccountService interface {
        Get(ctx context.Context, id int64) (*Account, error)
        List(cxt context.Context, account *Account) ([]*Account, error)
}

type Account struct {
        Id        int64     `json:"id"`
        Name      string    `json:"name"`
        Password  string    `json:"password"`
        Email     string    `json:"email"`
        UpdatedAt time.Time `json:"updated_at"`
        CreatedAt time.Time `json:"created_at"`
        Limit     int64     `json:"limit" gorm:"-"`
        Offset    int64     `json:"offset" gorm:"-"`
}

func (m *Account) TableName() string <span class="cov8" title="1">{
        return accountTableName
}</span>

func (m *Account) ToGrpc() *pub.Account <span class="cov0" title="0">{
        account := &amp;pub.Account{}
        if nil == m || m.IsEmpty() </span><span class="cov0" title="0">{
                return account
        }</span>

        <span class="cov0" title="0">return &amp;pub.Account{
                Id:        m.Id,
                Name:      m.Name,
                Password:  m.Password,
                Email:     m.Email,
                UpdatedAt: m.UpdatedAt.Format(consts.TimeFormatLayout),
                CreatedAt: m.CreatedAt.Format(consts.TimeFormatLayout),
        }</span>
}

func (m Account) IsEmpty() bool <span class="cov0" title="0">{
        return m == Account{}
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

import (
        "context"
        pub "vientiane/pub/idl/grpc"
)

const articleTableName = "vientiane_article"

type ArticleService interface {
        Get(ctx context.Context, id int64) (*Article, error)
        List(ctx context.Context, article *Article) ([]*Article, error)
        Add(ctx context.Context, article *Article) (err error)
        Del(ctx context.Context, id int64) (err error)
        Update(ctx context.Context,article *Article) (err error)
}

type Article struct {
        Id      int64  `json:"id"`
        Title   string `json:"title,omitempty"`
        Content string `json:"content,omitempty"`
        Author  string `json:"author"`
        Limit   int64  `json:"limit" gorm:"-"`
        Offset  int64  `json:"offset" gorm:"-"`
}

func (m *Article) ToGrpc() *pub.Article <span class="cov0" title="0">{
        article := &amp;pub.Article{}
        if nil == m || m.IsEmpty() </span><span class="cov0" title="0">{
                return article
        }</span>

        <span class="cov0" title="0">return &amp;pub.Article{
                Id:      m.Id,
                Title:   m.Title,
                Content: m.Content,
                Author:  m.Author,
        }</span>
}

func (m *Article) TableName() string <span class="cov8" title="1">{
        return articleTableName
}</span>

func (m Article) IsEmpty() bool <span class="cov8" title="1">{
        return m == Article{}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import "time"

const contentTableName = "vientiane_content"

type Content struct {
        Id          int64     `json:"id"`
        ContentInfo string    `json:"content"`
        Ct          time.Time `json:"ct"`
        Ut          time.Time `json:"ut"`
}

func (m *Content) TableName() string <span class="cov0" title="0">{
        return contentTableName
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import "time"

const docTableName = "vientiane_account"

type Doc struct {
        Id         int64     `json:"id"`
        Content    string    `json:"content"`
        CategoryId int64     `json:"category_id"`
        Author     string    `json:"author"`
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
}

func (m *Doc) TableName() string <span class="cov0" title="0">{
        return docTableName
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package mq

import (
        "context"
        "encoding/json"
        "github.com/segmentio/kafka-go"
        "go-micro.dev/v4/logger"
        "log"
        "vientiane/pub/adapter"
        pub "vientiane/pub/idl/grpc"
        "vientiane/server/models"
        "vientiane/server/service"
)

var (
        articleService = service.NewArticleService()
)

func ArticleConsumer() <span class="cov0" title="0">{
        // make a new reader that consumes from topic-A
        r := kafka.NewReader(kafka.ReaderConfig{
                Brokers:  []string{"localhost:9092"},
                GroupID:  "consumer-group-article",
                Topic:    adapter.TopicArticle,
                MinBytes: 10e3, // 10KB
                MaxBytes: 10e6, // 10MB
        })

        ctx := context.Background()
        for </span><span class="cov0" title="0">{
                m, err := r.FetchMessage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">msg := &amp;pub.ArticleMsg{}
                _ = json.Unmarshal(m.Value, msg)
                log.Println(msg)
                switch msg.WriteType </span>{
                case adapter.ArticleTypeInsert:<span class="cov0" title="0">
                        err = articleService.Add(ctx, &amp;models.Article{
                                Author:  msg.Article.Author,
                                Title:   msg.Article.Title,
                                Content: msg.Article.Content,
                        })</span>
                case adapter.ArticleTypeUpdate:<span class="cov0" title="0">
                        err = articleService.Update(ctx, &amp;models.Article{
                                Id: msg.Article.Id,
                                Author:  msg.Article.Author,
                                Title:   msg.Article.Title,
                                Content: msg.Article.Content,
                        })</span>
                case adapter.ArticleTypeDelete:<span class="cov0" title="0">
                        err = articleService.Del(ctx, msg.Article.Id)</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("consumer article msg err: %+v",err)
                        continue</span>
                }

                <span class="cov0" title="0">if err = r.CommitMessages(ctx, m); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("failed to commit messages:", err)
                }</span>
        }

        <span class="cov0" title="0">if err := r.Close(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to close reader:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package service

import (
        "context"
        "fmt"
        "vientiane/server/dao"
        "vientiane/server/database"
        "vientiane/server/models"
)

type AccountService struct {
        db  database.ManagerDB
        dao *dao.AccountDAO
}

func NewAccountService() models.AccountService <span class="cov8" title="1">{
        return &amp;AccountService{
                db:  database.NewDB(),
                dao: dao.NewAccountDAO(),
        }
}</span>

func (s *AccountService) Get(ctx context.Context, id int64) (account *models.Account, err error) <span class="cov0" title="0">{
        fun := "AccountService.Get--&gt;"
        if id &lt; 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">db, err := s.db.GetDB()
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get db err: %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">account, err = s.dao.Get(ctx, id, db)
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}

func (s *AccountService) List(ctx context.Context, account *models.Account) (accounts []*models.Account, err error) <span class="cov0" title="0">{
        fun := "AccountService.List--&gt;"

        if nil == account </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s account is nil", fun)
                return
        }</span>

        <span class="cov0" title="0">db, err := s.db.GetDB()
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get db err: %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">accounts, err = s.dao.List(ctx, account, db)
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s %v", fun, err)
                return
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import (
        "context"
        "fmt"
        "vientiane/server/dao"
        "vientiane/server/database"
        "vientiane/server/models"
)

type ArticleService struct {
        db  database.ManagerDB
        dao *dao.ArticleDAO
}

func NewArticleService() models.ArticleService <span class="cov8" title="1">{
        return &amp;ArticleService{
                db:  database.NewDB(),
                dao: dao.NewArticleDAO(),
        }
}</span>

func (a *ArticleService) Get(ctx context.Context, id int64) (*models.Article, error) <span class="cov0" title="0">{
        fun := "ArticleService.Get --&gt;"
        db, err := a.db.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get db err: %v", fun, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">article, err := a.dao.Get(ctx, id, db)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get article err: %v", fun, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return article, nil</span>
}

func (a *ArticleService) List(ctx context.Context, article *models.Article) ([]*models.Article, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (a *ArticleService) Add(ctx context.Context, article *models.Article) (err error) <span class="cov0" title="0">{
        fun := "ArticleService.Add --&gt;"
        db, err := a.db.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get db err: %v", fun, err)
                return err
        }</span>

        <span class="cov0" title="0">err = a.dao.Add(ctx, article, db)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s add article err: %v", fun, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *ArticleService) Del(ctx context.Context, id int64) (err error) <span class="cov0" title="0">{
        fun := "ArticleService.Del --&gt;"
        db, err := a.db.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get db err: %v", fun, err)
                return err
        }</span>

        <span class="cov0" title="0">err = a.dao.Del(ctx, id, db)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s del article err: %v", fun, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *ArticleService) Update(ctx context.Context, article *models.Article) (err error) <span class="cov0" title="0">{
        fun := "ArticleService.Update --&gt;"
        db, err := a.db.GetDB()
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s get db err: %v", fun, err)
                return err
        }</span>

        <span class="cov0" title="0">err = a.dao.Set(ctx, article, db)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s update article err: %v", fun, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

type dataQuery struct {
}

type DataQueryService interface {
}

func NewDataQueryService() DataQueryService <span class="cov0" title="0">{
        return &amp;dataQuery{}
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package entity

import (
        "fmt"
        "vientiane/server/consts"
)

type Condition struct {
        Field  string      `json:"field"`
        OpType string      `json:"op_type"`
        Value  interface{} `json:"value"`
}

type Conditions struct {
        Musts   []Conditions `json:"musts"`
        Should  []Conditions `json:"should"`
        MustNot []Conditions `json:"must_not"`
        Cond    *Condition   `json:"cond"`
}

type ESQueryParam struct {
        From   int64             `json:"from,omitempty"`
        Size   int64             `json:"size,omitempty"`
        Query  *ESQueryParamBool `json:"query,omitempty"`
        Sort   []string          `json:"sort,omitempty"`
        Source []string          `json:"_source,omitempty"`
}

type ESQueryParamBool struct {
        Bool *ESBoolQueryParamBool `json:"bool"`
}

type ESBoolQueryParamBool struct {
        Filter  []map[string]interface{} `json:"filter"`
        Should  []map[string]interface{} `json:"should"`
        MustNot []map[string]interface{} `json:"must_not"`
}

// 将条件解析为 es 查询条件
func ParseToES(cond *Conditions) *ESQueryParamBool <span class="cov8" title="1">{
        query := &amp;ESQueryParamBool{
                Bool: &amp;ESBoolQueryParamBool{
                        Filter:  parseToESParam(cond.Musts),
                        Should:  parseToESParam(cond.Should),
                        MustNot: parseToESParam(cond.MustNot),
                },
        }
        return query
}</span>

func parseToESParam(conds []Conditions) []map[string]interface{} <span class="cov8" title="1">{
        if len(conds) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">esConds := make([]map[string]interface{}, 0)
        for _, cond := range conds </span><span class="cov0" title="0">{
                m := make(map[string]interface{})

                if len(cond.Musts) &gt; 0 || len(cond.Should) &gt; 0 || len(cond.MustNot) &gt; 0 </span><span class="cov0" title="0">{
                        m["bool"] = &amp;ESBoolQueryParamBool{
                                Filter:  parseToESParam(cond.Musts),
                                Should:  parseToESParam(cond.Should),
                                MustNot: parseToESParam(cond.MustNot),
                        }
                }</span>

                <span class="cov0" title="0">if cond.Cond != nil </span><span class="cov0" title="0">{
                        switch cond.Cond.OpType </span>{
                        case consts.ESOpTypeEq:<span class="cov0" title="0">
                                m["term"] = map[string]interface{}{
                                        cond.Cond.Field: cond.Cond.Value,
                                }</span>
                        case consts.ESOpTypeExist:<span class="cov0" title="0">
                                m["exists"] = map[string]interface{}{
                                        cond.Cond.Field: cond.Cond.Value,
                                }</span>
                        case consts.ESOpTypeIn:<span class="cov0" title="0">
                                m["terms"] = map[string]interface{}{
                                        cond.Cond.Field: cond.Cond.Value,
                                }</span>
                        case consts.ESOpTypeGt, consts.ESOpTypeGte, consts.ESOpTypeLt, consts.ESOpTypeLte:<span class="cov0" title="0">
                                m["range"] = map[string]interface{}{
                                        cond.Cond.Field: cond.Cond.Value,
                                }</span>
                        case consts.ESOpTypeRegexp:<span class="cov0" title="0">
                                m["regexp"] = map[string]interface{}{
                                        cond.Cond.Field: map[string]interface{}{"value": fmt.Sprintf(".*%v.*", cond.Cond.Value), "flags": "ALL"},
                                }</span>
                        }
                }
                <span class="cov0" title="0">esConds = append(esConds, m)</span>
        }

        <span class="cov0" title="0">return esConds</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import "vientiane/server/models"

var (
        AccountServiceImpl models.AccountService
)

func init() <span class="cov8" title="1">{
        AccountServiceImpl = NewAccountService()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package utils

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "encoding/base64"
        "fmt"
        "vientiane/server/consts"
)

/**
 * AES 加解密算法
 */

func AESEncrypt(val string) (mobile string, err error) <span class="cov8" title="1">{
        fun := "Utils.AESEncrypt"

        block, err := aes.NewCipher([]byte(consts.AESSalt))
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s new cipher by salt: %s err", fun, consts.AESSalt)
                return
        }</span>

        <span class="cov8" title="1">data := pKCS7Padding([]byte(val), block.BlockSize())
        crypted := make([]byte, len(data))
        encrypter := cipher.NewCBCEncrypter(block, []byte(consts.AESSalt[:block.BlockSize()]))
        encrypter.CryptBlocks(crypted, data)

        mobile = base64.StdEncoding.EncodeToString(crypted)
        return</span>
}

func AESDecrypt(val string) (mobile string, err error) <span class="cov8" title="1">{
        fun := "Utils.AESDecrypt"

        phone, err := base64.StdEncoding.DecodeString(val)
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s base64 decoding err", fun)
                return
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher([]byte(consts.AESSalt))
        if nil != err </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s new cipher by salt: %s err", fun, consts.AESSalt)
                return
        }</span>

        <span class="cov8" title="1">crypted := make([]byte, len(phone))
        decrypter := cipher.NewCBCDecrypter(block, []byte(consts.AESSalt[:block.BlockSize()]))

        decrypter.CryptBlocks(crypted, phone)
        crypted = pKCS7UnPadding(crypted)

        mobile = string(crypted)
        return</span>
}

func pKCS7Padding(cipherText []byte, blockSize int) []byte <span class="cov8" title="1">{
        padding := blockSize - len(cipherText)%blockSize
        padText := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(cipherText, padText...)
}</span>

func pKCS7UnPadding(origData []byte) []byte <span class="cov8" title="1">{
        length := len(origData)
        unPadding := int(origData[length-1])
        return origData[:(length - unPadding)]
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package utils

import (
        "github.com/golang/glog"
        "gopkg.in/gomail.v2"
)

type GMail struct {
}

func NewGMail() *GMail <span class="cov0" title="0">{
        return &amp;GMail{}
}</span>

func SendQQ(email, title, content string) <span class="cov0" title="0">{
        fun := "GMail.SendQQ--&gt;"
        m := gomail.NewMessage()
        m.SetHeader("From", "1208579668@qq.com")
        m.SetHeader("To", email)
        m.SetHeader("Subject", title)
        m.SetBody("text/html", content)

        d := gomail.NewDialer("smtp.qq.com", 465, "1208579668@qq.com", "kqiufdxbnnbligdg")
        if err := d.DialAndSend(m); err != nil </span><span class="cov0" title="0">{
                glog.Errorf("%s send to %s err: %v", fun, email, err)
                return
                // TODO 重试
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
